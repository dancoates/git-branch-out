#!/bin/bash
## Display usage information
usage () {
    echo "usage:" $@
    exit
}

die () {
    echo $@
    exit 
}

containsElement () {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

#Vars
mode=
dir=
url=
script=

# Check for build flag
while getopts "b:" OPTION
do
    case $OPTION in
    b)
        script="$OPTARG"
        echo "Build Flag set"
    ;;
    [?])
        echo "Build flag not set"
        exit 1
    ;;
    
    esac
done
shift $(($OPTIND-1))


# Check the type of argument passed
if [ $# -eq 2 ]
    then
    if [[ "$1" =~ "://" || "$1" =~ "git@" ]]
    then
        echo "Param is a URL and a path has been passed"
        url=$1
        mode=initial
        dir=$2
    else
        usage
        echo "Incorrect params"
    fi
elif [ $# -eq 1 ]
    then
    if [[ "$1" =~ "://" || "$1" =~ "git@" ]]
    then
        echo "Param is a URL"
        mode=initial
        url=$1
        dir="."
    else
        mode=update
        dir=$1
        echo "Param is a path"
    fi
elif [ $# -eq 0 ]
    then
    if [ -d .git ]
    then
        mode=update
        dir="."
        echo "Currently in git directory"
    else
        echo "Not a git repository"
        mode=update
        dir="repo"
    fi
else
    usage
fi

## Git New Workdir Script
## https://github.com/git/git/blob/master/contrib/workdir/git-new-workdir

git_new_workdir() {
    orig_git=$1
    new_workdir=$2
    branch=$3

    # want to make sure that what is pointed to has a .git directory ...
    git_dir=$(cd "$orig_git" 2>/dev/null &&
      git rev-parse --git-dir 2>/dev/null) ||
      die "Not a git repository: \"$orig_git\""

    case "$git_dir" in
    .git)
        git_dir="$orig_git/.git"
        ;;
    .)
        git_dir=$orig_git
        ;;
    esac

    # don't link to a configured bare repository
    isbare=$(git --git-dir="$git_dir" config --bool --get core.bare)
    if test ztrue = z$isbare
    then
        die "\"$git_dir\" has core.bare set to true," \
            " remove from \"$git_dir/config\" to use $0"
    fi

    # don't link to a workdir
    if test -h "$git_dir/config"
    then
        die "\"$orig_git\" is a working directory only, please specify" \
            "a complete repository."
    fi

    # don't recreate a workdir over an existing repository
    if test -e "$new_workdir"
    then
        die "destination directory '$new_workdir' already exists."
    fi

    # make sure the links use full paths
    git_dir=$(cd "$git_dir"; pwd)

    # create the workdir
    mkdir -p "$new_workdir/.git" || die "unable to create \"$new_workdir\"!"

    # create the links to the original repo.  explicitly exclude index, HEAD and
    # logs/HEAD from the list since they are purely related to the current working
    # directory, and should not be shared.
    for x in config refs logs/refs objects info hooks packed-refs remotes rr-cache svn
    do
        case $x in
        */*)
            mkdir -p "$(dirname "$new_workdir/.git/$x")"
            ;;
        esac
        ln -s "$git_dir/$x" "$new_workdir/.git/$x"
    done

    # now setup the workdir
    cd "$new_workdir"
    # copy the HEAD from the original repository as a default branch
    cp "$git_dir/HEAD" .git/HEAD
    # checkout the branch (either the same as HEAD from the original repository, or
    # the one that was asked for)
    git checkout -f $branch
}

ff_update() {
  REMOTES="$@";
  if [ -z "$REMOTES" ]; then
    REMOTES=$(git remote);
  fi
  REMOTES=$(echo "$REMOTES" | xargs -n1 echo)
  CLB=$(git branch -l|awk '/^\*/{print $2}');
  echo "$REMOTES" | while read REMOTE; do
    git remote update $REMOTE
    git remote show $REMOTE -n \
    | awk '/merges with remote/{print $5" "$1}' \
    | while read line; do
      RB=$(echo "$line"|cut -f1 -d" ");
      ARB="refs/remotes/$REMOTE/$RB";
      LB=$(echo "$line"|cut -f2 -d" ");
      ALB="refs/heads/$LB";
      NBEHIND=$(( $(git rev-list --count $ALB..$ARB 2>/dev/null) +0));
      NAHEAD=$(( $(git rev-list --count $ARB..$ALB 2>/dev/null) +0));
      if [ "$NBEHIND" -gt 0 ]; then
        if [ "$NAHEAD" -gt 0 ]; then
          echo " branch $LB is $NBEHIND commit(s) behind and $NAHEAD commit(s) ahead of $REMOTE/$RB. could not be fast-forwarded";
        elif [ "$LB" = "$CLB" ]; then
          echo " branch $LB was $NBEHIND commit(s) behind of $REMOTE/$RB. fast-forward merge";
          git merge -q $ARB;
        else
          echo " branch $LB was $NBEHIND commit(s) behind of $REMOTE/$RB. resetting local branch to remote";
          git branch -l -f $LB -t $ARB >/dev/null;
        fi
      fi
    done
  done
}




mkdir -p $dir;
cd $dir;
if [ $mode = initial ]
    then
    echo "Inital Setup Mode"
    git clone --no-checkout  --no-single-branch --depth 1 $url repo;
    cd repo;
    dir=$(pwd)
    echo "Fanning out branches"
    echo "Updating"
    git fetch
    git for-each-ref --shell refs/remotes/origin/ --format="branch=%(refname:short)" | \
    while read entry
    do
        cd $dir
        eval "$entry"
        shortbranch=${branch/origin\//}
        if [ "$shortbranch" != "HEAD" ]
            then
            echo "Fanning branch $shortbranch"
            git_new_workdir . ../$shortbranch $shortbranch
            echo "Running Build Script"
            eval $script
        fi
    done
elif [ $mode = update ]
    then
    echo "Update Mode"
    if [ ! -d .git ]
    then
        cd repo
    fi
    dir=$(pwd)
    echo "Updating"
    git fetch
    ff_update

    to_prune="`git remote prune origin --dry-run 2>/dev/null`"
    prune="`echo $to_prune | grep -o "\[would prune\].*"` *"

    git for-each-ref --shell refs/remotes/origin/ --format="branch=%(refname:short)" | \
    while read entry
    do
        cd $dir
        eval "$entry"
        shortbranch=${branch/origin\//}
        if [ "$shortbranch" != "HEAD" ]
            then
            if [ ! -d ../$shortbranch ]
                then
                echo "Adding new branch $shortbranch"
                git_new_workdir . ../$shortbranch $shortbranch
                echo "Running Build Script"
                eval $script
            else
                if [[ "$prune" =~ "/$shortbranch *" ]]
                    then
                    echo "Deleting branch: $shortbranch"
                    git branch -D $shortbranch
                    rm -r ../$shortbranch
                    echo "$shortbranch will be pruned from remotes as well..."
                else
                    echo "Updating branch $shortbranch"
                    cd ../$shortbranch
                    git reset --hard
                    echo "Running Build Script"
                    eval $script
                fi
            fi
        fi
    done
    git remote prune origin

fi









